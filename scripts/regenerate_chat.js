const fs = require('fs');

function createRng(seed = 20260206) {
  let s = seed >>> 0;
  return function rng() {
    s = (s * 1664525 + 1013904223) >>> 0;
    return s / 4294967296;
  };
}

const rng = createRng();
const pick = (arr) => arr[Math.floor(rng() * arr.length)];

function normalizeText(text) {
  return text
    .toLowerCase()
    .replace(/[0-9]/g, '#')
    .replace(/[^\p{L}\p{N}\s]/gu, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function grams3(text) {
  const s = normalizeText(text).replace(/\s/g, '');
  if (s.length < 3) return new Set([s]);
  const out = new Set();
  for (let i = 0; i <= s.length - 3; i += 1) out.add(s.slice(i, i + 3));
  return out;
}

function jaccard(a, b) {
  let inter = 0;
  for (const x of a) if (b.has(x)) inter += 1;
  const union = a.size + b.size - inter;
  return union === 0 ? 1 : inter / union;
}

function render(template, vars) {
  return template.replace(/\{(\w+)\}/g, (_, key) => vars[key] || '');
}

function createLines({ target, templates, pools, sim = 0.86 }) {
  const lines = [];
  const seen = new Set();
  const gramCache = [];
  const patternUse = Array(templates.length).fill(0);
  const patternCap = Math.ceil(target / templates.length) + 8;

  let tries = 0;
  const maxTries = 1200000;

  while (lines.length < target && tries < maxTries) {
    tries += 1;

    const tid = Math.floor(rng() * templates.length);
    if (patternUse[tid] >= patternCap) continue;

    const vars = {};
    for (const [k, arr] of Object.entries(pools)) vars[k] = pick(arr);
    const line = render(templates[tid], vars).replace(/\s+/g, ' ').trim();

    if (line.length < 8) continue;
    if (seen.has(line)) continue;

    const g = grams3(line);
    let tooClose = false;
    for (const prev of gramCache) {
      if (jaccard(g, prev) >= sim) {
        tooClose = true;
        break;
      }
    }
    if (tooClose) continue;

    seen.add(line);
    gramCache.push(g);
    lines.push({ text: line });
    patternUse[tid] += 1;
  }

  if (lines.length !== target) {
    throw new Error(`Need ${target}, got ${lines.length}`);
  }

  return lines;
}

const shared = {
  spot: ['문틈', '복도 끝', '천장 모서리', '창문 옆', '계단 입구', '욕실 문앞', '주방 코너', '거실 안쪽', '현관 앞', '베란다 문'],
  sign: ['발소리', '긁는 소리', '숨소리', '금속음', '물방울 소리', '저주파 웅웅거림', '전자음', '마찰음', '탁 치는 소리', '한숨 같은 소리'],
  mood: ['쎄하다', '불길하다', '서늘하다', '이상하다', '정적이 무겁다', '공기가 눌린다', '기척이 선명하다', '심박이 오른다'],
  end: ['같네요', '느낌입니다', '확실해 보입니다', '체감돼요', '아닌가요', '맞죠', '라고 봅니다', '수준입니다'],
};

function categoryGreeting() {
  const templates = [
    '{hello}. 시작 화면부터 {mood}.',
    '{hello}, 첫 컷인데 {spot} 쪽이 먼저 거슬립니다.',
    '방금 합류했는데 도입부터 공기 압박이 세네요.',
    '오프닝인데도 {sign} 레이어가 분리돼 들립니다.',
    '출석합니다. {spot} 주변 밝기만 미묘하게 다릅니다.',
    '라이브 진입 완료, 시작 10초 만에 긴장 올라오네요.',
    '첫 장면인데 {mood} 쪽으로 바로 기울어요.',
    '초반 무드가 평소보다 훨씬 건조하고 차갑습니다.',
    '채팅 도착. 오늘은 프롤로그부터 공포 밀도가 높네요.',
    '입장하자마자 {spot} 라인에 시선이 고정됩니다.',
    '본방 왔는데 시작 BGM보다 공간음이 더 무섭네요.',
    '스타트 컷부터 이미 탐색보다 생존이 먼저 떠오릅니다.',
    '{hello}. 첫 프레임 질감이 너무 차갑습니다.',
    '오프닝인데 정적 길이가 묘하게 길어요.',
    '방 들어오자마자 느낌 왔습니다. 오늘 판 어렵겠네요.',
    '시작 멘트 듣는 동안에도 {sign}가 사라지지 않아요.',
    '{spot} 쪽 노이즈만 따로 살아 있는 느낌입니다.',
    '합류 완료. 도입부터 감정선이 확 눌리네요.',
    '첫 화면에서 {spot}이 가장 위험하게 보입니다.',
    '오프닝 연출치고는 {mood} 강도가 과합니다.',
    '{hello}. 오늘은 초반부터 손에 땀 차네요.',
    '진입하자마자 카메라 가장자리 떨림이 거슬립니다.',
    '이 정도면 시작 장면이 아니라 경고 구간이네요.',
    '막 들어왔는데도 이미 후퇴 루트부터 보게 됩니다.',
    '첫 컷부터 {spot} 그림자 밀도가 심상치 않아요.',
    '도입인데 심박이 먼저 반응하는 타입입니다.',
    '{hello}. 오늘은 "안전" 단어가 안 떠오릅니다.',
    '초반 프레임만 봐도 탐색 난이도 높은 맵 같아요.',
    '{spot} 근처 기류가 화면 밖까지 전달되는 느낌.',
    '오프닝인데 벌써 시야보다 청각이 더 위협적이네요.'
  ];

  const pools = {
    hello: ['입장 완료', '출석 체크', '채팅 합류', '라이브 확인', '본방 사수', '방금 도착'],
    spot: shared.spot,
    sign: shared.sign,
    mood: shared.mood,
  };

  return createLines({ target: 300, templates, pools, sim: 0.86 });
}

function categoryQuestion() {
  const templates = [
    '방금 {sign} 들은 사람 저뿐인가요?',
    '{spot} 쪽 지나간 그림자 보신 분 있어요?',
    '지금 동선 계속 밀어도 되는 각인가요?',
    '이 구간은 후퇴가 맞을까요 확인 진입이 맞을까요?',
    '손전등 각도 낮추는 게 더 안전하지 않나요?',
    '왜 화면 가장자리만 계속 흔들리는 거죠?',
    '마이크 게인이 올라간 건지 실제 소리인지 헷갈립니다.',
    '문 열림 직후 공간 크기가 달라진 느낌 안 드나요?',
    '{spot} 먼저 체크하고 가는 게 맞죠?',
    '지금 페이스면 점프스케어 대응 가능해 보여요?',
    '채팅 기준으로 현 위치 위험도 몇 점쯤 되나요?',
    '카메라 초점이 저기 고정되는 이유가 있을까요?',
    '{sign} 거리감이 갑자기 가까워진 거 맞아요?',
    '{spot} 문 각도 원래 저렇게 열려 있었나요?',
    '왼쪽 먼저 볼까요, 뒤쪽 먼저 확인할까요?',
    '진입 전에 오디오 체크 한 번 더 해야 하지 않나요?',
    '지금 멈추고 재정비하는 게 낫겠죠?',
    '이 정적 길이면 이벤트 직전이라고 봐도 되나요?',
    '프레임 드랍인지 실제 흔들림인지 구분 가능해요?',
    '문턱 넘기 전에 채팅 다수 의견 받을게요, 어때요?',
    '지금 장비 상태로 암실 들어가도 괜찮을까요?',
    '바닥 반사광이 변하는데 광원 하나뿐 맞나요?',
    '아까 {spot}에서 움직인 거 본 사람?',
    '지금 신호면 탐색보다 대기 선택이 맞을까요?',
    '저 저주파, 심박음이랑 겹쳐 들리는 거 저만 그래요?',
    '손전등 떨림이 손 문제인지 외부 충격인지 모르겠네요.',
    '문 닫히는 템포 비정상적으로 빠르지 않았어요?',
    '지금 바로 들어가면 리스크가 큰 편인가요?',
    '다음 한 걸음 어디로 두는 게 제일 안전할까요?',
    '이번 패턴은 트리거인지 페이크인지 판단 가능해요?'
  ];

  const pools = { spot: shared.spot, sign: shared.sign };
  return createLines({ target: 300, templates, pools, sim: 0.86 });
}

function categoryHorror() {
  const templates = [
    '{spot} 쪽은 보고만 있어도 등골이 식습니다.',
    '정적이 길어질수록 심장이 더 크게 뛰네요.',
    '점프스케어 없어도 이 구간은 공포가 충분합니다.',
    '소리 끊긴 순간이 오히려 제일 위협적이네요.',
    '{sign} 가까워지는 느낌 때문에 손끝이 차가워집니다.',
    '카메라 밖 시선이 계속 걸려서 숨이 막혀요.',
    '프레임 구석 어두워질 때마다 긴장선이 올라갑니다.',
    '공간 자체가 사람을 밀어내는 분위기입니다.',
    '{spot}에 초점 잡힐 때마다 몸이 먼저 반응해요.',
    '빛이 약해지는 타이밍이 너무 정확해서 무섭네요.',
    '놀람보다 압박으로 무너뜨리는 유형의 맵입니다.',
    '불이 켜져 있어도 안전하다는 느낌이 전혀 없습니다.',
    '발소리보다 침묵이 더 크게 들리는 게 진짜 공포예요.',
    '현관 쪽 화면만 보면 목덜미가 굳습니다.',
    '사람 없는 집인데 인기척은 너무 선명합니다.',
    '눈 돌리는 동작 자체가 이벤트처럼 느껴져요.',
    '이 공포는 순간이 아니라 지속으로 눌러옵니다.',
    '공기 온도가 아니라 공간 무게가 변한 느낌입니다.',
    '진입 전인데 벌써 퇴로부터 찾게 되네요.',
    '{sign} 끊기는 지점이 없어서 더 불안합니다.',
    '카메라 흔들릴 때 공포감이 아니라 공황감이 옵니다.',
    '여긴 시각보다 청각이 먼저 사람을 무너뜨리네요.',
    '{spot} 라인 따라가면 체감 온도가 확 떨어집니다.',
    '밝기는 정상인데 장면이 계속 어둡게 느껴져요.',
    '분위기만으로 체력 깎는 맵이라는 말이 맞네요.',
    '문턱만 넘으면 뭔가 틀어질 것 같은 느낌입니다.',
    '잔향이 길게 남아서 현실감이 깨집니다.',
    '호흡 고르고 봐도 긴장이 잘 안 풀립니다.',
    '뒤돌아보는 순간이 제일 무섭습니다.',
    '설명 안 되는 불안이 같은 속도로 계속 따라옵니다.'
  ];

  const pools = { spot: shared.spot, sign: shared.sign };
  return createLines({ target: 300, templates, pools, sim: 0.86 });
}

function categoryWarning() {
  const templates = [
    '지금은 전진 금지, {spot} 먼저 확인하세요.',
    '속도 줄이세요. 시야 확보가 우선입니다.',
    '{sign} 가까워졌습니다. 한 걸음 뒤로 빠지세요.',
    '문 바로 열지 말고 손전등부터 넣어 보세요.',
    '오른쪽 사각 큽니다. 고개 먼저 돌려 확인.',
    '뒤쪽 소리 커졌어요. 일단 멈추는 게 맞습니다.',
    '{spot} 진입은 잠시 보류하세요.',
    '바닥 반사 이상합니다. 발 위치 다시 잡으세요.',
    '현재 위치 위험도 높음, 후퇴 2걸음 권장.',
    '문턱 넘기 전 조명 각도부터 재설정하세요.',
    '지금은 탐색이 아니라 확인 단계입니다.',
    '정면보다 측면부터 보는 게 안전합니다.',
    '{spot} 앞 공기 흔들림 보입니다. 즉시 정지.',
    '경고, 이 패턴은 진입 신호가 아닙니다.',
    '장비 점검 먼저 하고 들어가세요.',
    '조명 깜빡임 확인됨. 소등 전에 후퇴.',
    '프레임 밖 반응 있습니다. 시야 넓히세요.',
    '채팅 다수 위험 표시 중입니다. 멈춰요.',
    '안전 동선으로 갈아타세요. 욕심내면 위험합니다.',
    '{sign} 방향 바뀝니다. 추적하지 마세요.',
    '문 열려 있어도 지금은 함부로 진입하면 안 됩니다.',
    '상태 안 좋습니다. 5초 정지 후 재판단하세요.',
    '한 번에 깊게 들어가지 말고 절반 접근만 하세요.',
    '{spot}는 각도 없이 들어가면 당합니다.',
    '급하게 돌지 말고 뒤쪽 먼저 체크하세요.',
    '이 타이밍 이벤트 유도 구간 같습니다.',
    '지금 판단 미스 나기 쉬운 구간이에요.',
    '정적 길어진 뒤가 가장 위험합니다.',
    '바닥 상태 불명입니다. 짧게 이동하세요.',
    '진입보다 생존 우선, 후퇴가 맞습니다.'
  ];

  const pools = { spot: shared.spot, sign: shared.sign };
  return createLines({ target: 300, templates, pools, sim: 0.86 });
}

function categoryTroll() {
  const templates = [
    '귀신도 오늘은 시청자 모드로 관전 중일 듯합니다.',
    '이 정도면 악령이 먼저 후원 버튼 누르겠네요.',
    '방금 표정 저장 완료, 썸네일 자동 생성입니다.',
    '점프스케어 나오면 인사부터 하고 시작합시다.',
    '퇴마보다 멘트가 먼저 나오는 채널입니다.',
    '유령이 봐도 리액션 좋다고 할 장면이네요.',
    '이 집은 벽지가 주연, 사람은 게스트 느낌입니다.',
    '지금 심박이 배경음보다 더 큰 것 같은데요.',
    '귀신 등장하면 닉네임부터 물어봐 주세요.',
    '합방 제안 오면 오늘 바로 수락각입니다.',
    '방송 끝나면 악령도 클립 돌려볼 듯합니다.',
    '공포게임인데 채팅이 제일 시끄럽네요.',
    '문 열기 전에 광고 멘트 한 줄 읽고 가죠.',
    '오늘 리액션 폼 너무 좋아서 무섭고 웃깁니다.',
    '귀신 입장에서도 오늘은 이벤트 방송이겠네요.',
    '놀라는 속도 측정하면 상위권 확정입니다.',
    'PD보다 귀신이 동선 관리 더 잘할 수도요.',
    '저 문 뒤에 있으면 저도 박수 칠 것 같습니다.',
    '겁먹은 표정이 너무 정확해서 연출 같아요.',
    '지금 채팅 드립 밀도가 공포 밀도 넘겼습니다.',
    '악령도 알림 켜고 대기했을 타이밍이네요.',
    '방금 장면 클립 제목까지 자동 완성입니다.',
    '퇴근한 귀신 다시 출근시키는 방송이에요.',
    '이 구간 넘기면 유령 팬카페 열릴 듯합니다.',
    '점프스케어보다 채팅 반응이 더 빠릅니다.',
    '오늘은 인간 vs 공포가 아니라 인간 vs 심박이네요.',
    '귀신 놀랄까 봐 제가 대신 웃고 있습니다.',
    '무서운 건 맞는데 리액션이 더 재밌습니다.',
    '집주인 영혼도 구독 유지할 것 같은 텐션.',
    '이 기세면 폐허도 예능 세트장 됩니다.'
  ];

  const pools = {};
  return createLines({ target: 300, templates, pools, sim: 0.86 });
}

function categorySupport() {
  const templates = [
    '천천히 가도 됩니다. 지금 페이스 좋습니다.',
    '무리하지 말고 안전 우선으로 진행해요.',
    '확인 후 이동하는 방식, 지금 아주 안정적입니다.',
    '긴장 구간인데도 판단이 흔들리지 않네요.',
    '호흡 조절 잘하고 있습니다. 그대로 가요.',
    '불안하면 후퇴해도 됩니다. 계속 응원합니다.',
    '시야 확보 먼저 하는 습관이 정말 좋네요.',
    '어두운 구간에서도 관찰력이 유지됩니다.',
    '속도 조절 깔끔해서 완주 가능해 보여요.',
    '지금 선택들이 전반적으로 합리적입니다.',
    '겁나는 상황인데도 컨트롤이 안정적입니다.',
    '이 페이스면 실수 없이 넘어갈 수 있어요.',
    '채팅 다수 응원 중입니다. 끝까지 같이 갑시다.',
    '판단 우선순위가 명확해서 든든합니다.',
    '무서운 장면 지나도 멘탈 잘 유지 중이에요.',
    '중요한 건 생존입니다. 신중한 플레이 좋아요.',
    '한 템포 쉬고 가는 선택도 좋은 선택입니다.',
    '차분하게 정보 모으는 방식이 정답에 가깝습니다.',
    '스스로 속도 조절하는 게 프로다운 플레이예요.',
    '불빛 운용이 좋아서 상황 파악이 쉽습니다.',
    '안전하게 가는 플레이가 결국 가장 강합니다.',
    '긴장될수록 침착함이 더 빛나네요.',
    '여기까지 온 것만으로도 충분히 잘하고 있어요.',
    '공격적이지 않은 판단이 오히려 정확합니다.',
    '한 걸음씩 확인하는 방식 계속 유지합시다.',
    '실수 줄이려는 태도가 화면에 그대로 보여요.',
    '지금 기준이면 클리어 충분히 가능합니다.',
    '급해지지 않는 플레이가 진짜 실력입니다.',
    '위험 구간에서도 중심 안 잃는 게 최고입니다.',
    '끝까지 차분하게, 채팅은 계속 옆에 있을게요.'
  ];

  const pools = {};
  return createLines({ target: 300, templates, pools, sim: 0.86 });
}

function categoryAnalysis() {
  const templates = [
    '{metric} 기준으로 정상 범위를 벗어났습니다.',
    '직전 구간 대비 {metric} 변동폭이 과도합니다.',
    '{metric} 패턴이 자연 잡음과 다르게 반복됩니다.',
    '오디오 이벤트와 비디오 이벤트 시점이 어긋납니다.',
    '단순 흔들림으로 설명하기 어려운 신호가 남습니다.',
    '정적 구간에서만 {metric}이 커지는 점이 핵심입니다.',
    '{metric} 추세선이 동선과 반대로 움직입니다.',
    '프레임 단위로 이상 신호가 재현됩니다.',
    '환경 반사음으로 보기 힘든 {metric} 값입니다.',
    '문턱 통과 직후 {metric} 급상승이 반복됩니다.',
    '현재 데이터는 단일 원인보다 복합 원인에 가깝습니다.',
    '소스 없는 잡음이 {metric} 구간에 집중됩니다.',
    '감지 변화량이 카메라 움직임 대비 과합니다.',
    '{metric} 변화만 보면 고정 물체 반응이 아닙니다.',
    '신호 세기와 거리감이 물리적으로 맞지 않습니다.',
    '공간 잔향 특성상 현재 수치 설명이 어렵습니다.',
    '우연 패턴보다 의도 신호 가능성이 높아 보입니다.',
    '{metric} 재측정 필요합니다. 값이 계속 튑니다.',
    '초점 이동 없이 {metric}만 흔들리는 점이 이상합니다.',
    '시간축 기준 이벤트 간격이 규칙적으로 당겨집니다.',
    '같은 위치 재진입 시 값이 달라지는 건 비정상입니다.',
    '잡음 바닥값이 상승해 기저 상태가 바뀌었습니다.',
    '{metric} 신호가 벽 반사보다 직접 신호에 가깝습니다.',
    '광원 변화 없는 프레임에서 수치만 출렁입니다.',
    '현재 로그로는 외부 개입 가능성을 배제하기 어렵습니다.',
    '패턴 길이 불규칙성 때문에 랜덤 잡음 가정이 약합니다.',
    '열원 이동 가설의 설명력이 가장 높습니다.',
    '동선상 막힌 방향에서만 반응이 커지는 중입니다.',
    '정상 장비라면 나오기 어려운 파형이 찍힙니다.',
    '요약하면 현재 구간은 위험 신호가 누적된 상태입니다.'
  ];

  const pools = {
    metric: ['소리 간격', '잔향 길이', '노이즈 분포', '노출 변화', '초점 이동량', '저주파 세기', '온도 추정치', '그림자 길이', '프레임 흔들림', '신호 지연값'],
  };

  return createLines({ target: 300, templates, pools, sim: 0.86 });
}

function categoryJumpscare() {
  const templates = [
    '심장 떨어질 뻔했습니다. 타이밍이 너무 악랄하네요.',
    '의자에서 튀어올랐어요, 준비 시간 0초였습니다.',
    '이어폰 던질 뻔했네요. 사운드 설계가 셉니다.',
    '방금 건 반칙 수준입니다. 정적 뒤에 바로 터졌어요.',
    '숨 멎는 줄 알았습니다. 경고 없이 들어오네요.',
    '손에 땀 차는 정도가 아니라 손이 굳었습니다.',
    '갑툭튀 진입 각이 완전히 사각이었습니다.',
    '맥박이 아직 안 내려갑니다. 다시 보기 힘들어요.',
    '볼륨 올린 사람들은 전부 피해자네요.',
    '예고 없는 진입이라 체감 공포 두 배입니다.',
    '화면 멈춘 줄 알았는데 바로 튀어나와 당했어요.',
    '소리 먼저 치고 그림자 따라와서 더 무서웠습니다.',
    '이번 점프스케어는 다시 보기 금지급입니다.',
    '정적 길이 계산하고 정확히 찔러오네요.',
    '반응할 틈 자체를 안 주는 방식이라 세네요.',
    '눈 깜빡이는 순간 들어와서 그대로 맞았습니다.',
    '귀가 먼저 놀라고 몸이 나중에 반응했어요.',
    '이건 공포라기보다 심장 테스트에 가깝습니다.',
    '소름이 아니라 순간 공황이 왔습니다.',
    '타이밍 읽었다고 생각했는데 완전히 빗나갔네요.',
    '예상 포인트를 피해서 들어와서 더 놀랐습니다.',
    '짧은 컷인데 여운이 길게 남습니다.',
    '컷 길이 대비 놀람 강도가 과하게 셉니다.',
    '이번 건 리액션이 아니라 생존 본능이었어요.',
    '긴장선 최고점에서 바로 끊어치기 들어옵니다.',
    '폰 놓칠 뻔해서 손에 힘 꽉 들어갔네요.',
    '등이 먼저 굳고 나서야 상황 파악됐습니다.',
    '심리전으로 올린 뒤 마지막 한 방이 세네요.',
    '점프스케어 후유증이 아직 남아 있습니다.',
    '이 타이밍은 알고도 막기 어려운 유형입니다.'
  ];

  const pools = {};
  return createLines({ target: 300, templates, pools, sim: 0.86 });
}

const data = {
  chat: {
    greeting: categoryGreeting(),
    question: categoryQuestion(),
    horror: categoryHorror(),
    warning: categoryWarning(),
    troll: categoryTroll(),
    support: categorySupport(),
    analysis: categoryAnalysis(),
    jumpscare_react: categoryJumpscare(),
  },
};

fs.writeFileSync('chat.json', JSON.stringify(data, null, 2) + '\n', 'utf8');
for (const [k, v] of Object.entries(data.chat)) console.log(k, v.length);
